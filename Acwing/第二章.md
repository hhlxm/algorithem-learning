# 目录

- [链表](#section1)
- [单调栈](#section2)
- [单调队列](#section3)
- [KMP](#section4)
- [位运算](#section5)
- [离散化处理](#section6)
- [区间合并](#section7)


## 链表 <a name="section1"></a>
一般用**数组**表示链表，因为在new新节点时，会花费时间。（在算法题里，只管时间，很少考虑空间）
```c++
const int N = 100010;
int e[N], ne[N], head, idx;

void Init() {
	head = -1;
	idx = 0;
}
```

### 注意
因为有删除操作导致数组不连续，所以表示下标的时候，一般不直接用常量去表示。


## 单调栈 <a name="section2"></a>
### 问题描述：
给定一个长度为 N 的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 −1。

### 暴力解决：
两个for循环遍历；

### 算法优化

一个数左边的等待比较的序列应该满足 靠后的数比考前的数要大 否则 a<b,but loc of a>b 那么当a不满足的时候，b肯定不满足。

所以当把新元素放入比较序列的时候，应该把比它大的元素去除：

```c++
	while (tt>=hh&&st[tt] >= x) {
			tt--;// 逻辑去除队列中比x大的元素
		}
		if (tt >= hh) {
			cout << st[tt]<<" ";
			
		}
		else {
			cout << -1 << " ";
			
		}
		st[++tt] = x;//新元素入栈
```

## 单调队列 <a name="section3"></a>
### 问题描述：
确定滑动窗口位于每个位置时，窗口中的最大值和最小值。

### 暴力解决：
每次移动一位，遍历框中的元素，找出最大最小值。



### 算法优化：
每一次与找框里的最小元素时，其实已经获得了一些信息，要保存下来

具体来说：存储已经找到的最小值，并存储单调队列，这样就不用新元素每次再去遍历框。而只要和单调队列去比较。

队列其实就是排队的意思，本身就应该有着单调性，又由于框的移动，导致队头会动，更加符合队列先进先出的思想。

```c++
for (int i = 0; i < n; i++) {
	//加入新元素

	//先看队列头有没有被移出
	if (hh <= tt&&i - k + 1 > q[hh])hh++;//队列与栈的不同，当框内最旧元素的下标要超过hh时，hh++
	
	//
	while (hh<=tt&&a[i] <= a[q[tt]])tt--;//思想同单调栈，新来的元素只会更又近又小的比，不会跟又远又大的比；

	q[++tt] = i;//去除远大的元素之后，把新元素放入

	if (i >= k - 1) {//当i的值大于等于框的大小时，再输出
		cout << a[q[hh]]<<" ";
	}
}
```

### 遇到的问题：
- 如果有小的元素要插入队列怎么办？

	- 答：不用插，因为插入的话就是最新的元素，可以把远大的元素丢掉，这样再下一个元素进来的时候，就会最先和这个想要插入的元素比较

- 框的移动会导致新元素比较的范围变化，如何处理？

	- 答：队列中最小的元素一定是在框内的，如果不在框内就会hh++到下一个；

## KMP <a name="section4"></a>
### 朴素算法：
一个一个移动，不等时，j回到原处，整体往后移一位。

### 算法优化
当子串中已经有部分匹配了，那最前那个元素不等时，不需要每次整体往后移动一位，可以移动多位！

- 那怎么判断移动到哪呢？这时需要求一个next数组
	- next[i]是以下标**i**（下标从**1**开始）为最后一个元素的字符串中的前缀与后缀相等的最大长度。

#### next数组求解算法实现：

```c++
next[1]=0;//一定满足的条件
//已知next[1]，所以从2开始自己与自己匹配
for(int i=2,j=0;i<=length;i++){
	//j即代表着下标，也代表着目前已经有多少个元素相匹配了
	while(j&&s[i]!=s[j+1]) j=next[j];//有元素匹配，而且最前的元素不匹配，这是需要移动下面那个串，怎么移动，移动到next[j];

	if(s[i]==s[j+1]) j++;//不管有没有元素匹配，如果最前的元素匹配了，那么已经匹配的元素加一

	next[i]=j;
}
```

这里求解的思想并没有按照求前缀与后缀相等的最大长度。而是在已知next[1]的基础上，按照匹配的思想进行求解next[2]

#### 匹配算法实现：
```c++
for(int i=1,j=0;i<=n;i++){
	while(j&&a[i]!=b[j+1])j=next[j];//最一般的情况：有元素匹配了，但是最新的元素不匹配，那么需要移动整个串，怎么移动呢，j=next[j];

	if(a[i]==b[j+1]) j++;//不管有没有元素匹配，最新的元素匹配，那么j指针可以往后移一位

	if(j==m)cout<<"YES!"<<endl;//j移到末尾，那么有母串中有子串
}
```

#### 注意：
这里的下标都从**1**开始！！！






 
	
