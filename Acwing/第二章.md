# 目录

- [链表](#section1)
- [单调栈](#section2)
- [单调队列](#section3)
- [双指针](#section4)
- [位运算](#section5)
- [离散化处理](#section6)
- [区间合并](#section7)


## 链表 <a name="section1"></a>
一般用**数组**表示链表，因为在new新节点时，会花费时间。（在算法题里，只管时间，很少考虑空间）
```c++
const int N = 100010;
int e[N], ne[N], head, idx;

void Init() {
	head = -1;
	idx = 0;
}
```

### 注意
因为有删除操作导致数组不连续，所以表示下标的时候，一般不直接用常量去表示。


## 单调栈 <a name="section2"></a>
### 问题描述：
给定一个长度为 N 的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 −1。

### 暴力解决：
两个for循环遍历；

### 算法优化

一个数左边的等待比较的序列应该满足 靠后的数比考前的数要大 否则 a<b,but loc of a>b 那么当a不满足的时候，b肯定不满足。

所以当把新元素放入比较序列的时候，应该把比它大的元素去除：

```c++
	while (tt>=hh&&st[tt] >= x) {
			tt--;// 逻辑去除队列中比x大的元素
		}
		if (tt >= hh) {
			cout << st[tt]<<" ";
			
		}
		else {
			cout << -1 << " ";
			
		}
		st[++tt] = x;//新元素入栈
```

## 单调队列 <a name="section3"></a>
### 问题描述：
确定滑动窗口位于每个位置时，窗口中的最大值和最小值。

### 暴力解决：
每次移动一位，遍历框中的元素，找出最大最小值。

### 算法优化：
