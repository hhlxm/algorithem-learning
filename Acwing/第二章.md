# 目录

- [链表](#section1)
- [单调栈](#section2)
- [单调队列](#section3)
- [双指针](#section4)
- [位运算](#section5)
- [离散化处理](#section6)
- [区间合并](#section7)


## 链表 <a name="section1"></a>
一般用**数组**表示链表，因为在new新节点时，会花费时间。（在算法题里，只管时间，很少考虑空间）
```c++
const int N = 100010;
int e[N], ne[N], head, idx;

void Init() {
	head = -1;
	idx = 0;
}
```

### 注意
因为有删除操作导致数组不连续，所以表示下标的时候，一般不直接用常量去表示。


## 单调栈 <a name="section2"></a>
### 问题描述：
给定一个长度为 N 的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 −1。

### 暴力解决：
两个for循环遍历；

### 算法优化

一个数左边的等待比较的序列应该满足 靠后的数比考前的数要大 否则 a<b,but loc of a>b 那么当a不满足的时候，b肯定不满足。

所以当把新元素放入比较序列的时候，应该把比它大的元素去除：

```c++
	while (tt>=hh&&st[tt] >= x) {
			tt--;// 逻辑去除队列中比x大的元素
		}
		if (tt >= hh) {
			cout << st[tt]<<" ";
			
		}
		else {
			cout << -1 << " ";
			
		}
		st[++tt] = x;//新元素入栈
```

## 单调队列 <a name="section3"></a>
### 问题描述：
确定滑动窗口位于每个位置时，窗口中的最大值和最小值。

### 暴力解决：
每次移动一位，遍历框中的元素，找出最大最小值。

### 算法优化：
队列其实就是排队的意思，本身就应该有着单调性，又由于框的移动，导致队头会动，更加符合队列先进先出的思想。

具体来说：存储已经找到的最小值，并存储单调队列，这样就不用新元素每次再去遍历框。而只要和单调队列去比较。
```c++
for (int i = 0; i < n; i++) {
	//加入新元素

	//先看队列头有没有被移出
	if (hh <= tt&&i - k + 1 > q[hh])hh++;//队列与栈的不同，当框内最旧元素的下标要超过hh时，hh++
	
	//
	while (hh<=tt&&a[i] <= a[q[tt]])tt--;//思想同单调栈，新来的元素只会更又近又小的比，不会跟又远又大的比；

	q[++tt] = i;//去除远大的元素之后，把新元素放入

	if (i >= k - 1) {//当i的值大于等于框的大小时，再输出
		cout << a[q[hh]]<<" ";
	}
}
```



