# 目录

- [链表](#section1)
- [单调栈](#section2)
- [单调队列](#section3)
- [KMP](#section4)
- [字典树Trie](#section5)
- [并查集](#section6)
- [堆排序](#section7)
- [哈希表](#section8)
# 综述

这一章的主要内容是用**数组**表示各种数据结构，因为在new新节点时，会花费时间。（在算法题里，只管时间，很少考虑空间）。而数组表示数据结构的时候，新结点，我们就用idx++，表示新结点的序号。

所以数组的下标其实就是相当于一个指针，指向一个结点。很多时候用结点的序号来当作指针，同时作为数组的下标。

所以就会有很多类似这样的思路：用一个数组存储序号，一个数组存储序号对应的值：

```c++
int element[N], label[N],idx;
element[label[++idx]]=elem;//新结点的值
```

抑或是这样的：

```c++
int label[N][26];//存储结点的记号,每个结点有26个子节点
int element[N];
int idx;//编号，或者说是指针

for(int i=0;i<s.size();i++){
        int c=s[i]-'a';
        if(t[temp_label][c]==0){//没有编号--新结点
            t[temp_label][c]=++label;
        }
        temp_label=t[temp_label][c];
    }
    element[temp_label]++;
```

## 链表 <a name="section1"></a>

```c++
const int N = 100010;
int e[N], ne[N], head, idx;

void Init() {
	head = -1;
	idx = 0;
}
```

### 注意
因为有删除操作导致数组不连续，所以表示下标的时候，一般不直接用常量去表示。


## 单调栈 <a name="section2"></a>
### 问题描述：
给定一个长度为 N 的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 −1。

### 暴力解决：
两个for循环遍历；

### 算法优化

一个数左边的等待比较的序列应该满足 靠后的数比考前的数要大 否则 a<b,but loc of a>b 那么当a不满足的时候，b肯定不满足。

所以当把新元素放入比较序列的时候，应该把比它大的元素去除：

```c++
	while (tt>=hh&&st[tt] >= x) {
			tt--;// 逻辑去除队列中比x大的元素
		}
		if (tt >= hh) {
			cout << st[tt]<<" ";
			
		}
		else {
			cout << -1 << " ";
			
		}
		st[++tt] = x;//新元素入栈
```

## 单调队列 <a name="section3"></a>
### 问题描述：
确定滑动窗口位于每个位置时，窗口中的最大值和最小值。

### 暴力解决：
每次移动一位，遍历框中的元素，找出最大最小值。



### 算法优化：
每一次与找框里的最小元素时，其实已经获得了一些信息，要保存下来

具体来说：存储已经找到的最小值，并存储单调队列，这样就不用新元素每次再去遍历框。而只要和单调队列去比较。

队列其实就是排队的意思，本身就应该有着单调性，又由于框的移动，导致队头会动，更加符合队列先进先出的思想。

```c++
for (int i = 0; i < n; i++) {
	//加入新元素

	//先看队列头有没有被移出
	if (hh <= tt&&i - k + 1 > q[hh])hh++;//队列与栈的不同，当框内最旧元素的下标要超过hh时，hh++
	
	//
	while (hh<=tt&&a[i] <= a[q[tt]])tt--;//思想同单调栈，新来的元素只会更又近又小的比，不会跟又远又大的比；

	q[++tt] = i;//去除远大的元素之后，把新元素放入

	if (i >= k - 1) {//当i的值大于等于框的大小时，再输出
		cout << a[q[hh]]<<" ";
	}
}
```

### 遇到的问题：
- 如果有小的元素要插入队列怎么办？

	- 答：不用插，因为插入的话就是最新的元素，可以把远大的元素丢掉，这样再下一个元素进来的时候，就会最先和这个想要插入的元素比较

- 框的移动会导致新元素比较的范围变化，如何处理？

	- 答：队列中最小的元素一定是在框内的，如果不在框内就会hh++到下一个；

## KMP <a name="section4"></a>
### 朴素算法：
一个一个移动，不等时，j回到原处，整体往后移一位。

### 算法优化
当子串中已经有部分匹配了，那最前那个元素不等时，不需要每次整体往后移动一位，可以移动多位！

- 那怎么判断移动到哪呢？这时需要求一个next数组
	- next[i]是以下标**i**（下标从**1**开始）为最后一个元素的字符串中的前缀与后缀相等的最大长度。

#### next数组求解算法实现：

```c++
next[1]=0;//一定满足的条件
//已知next[1]，所以从2开始自己与自己匹配
for(int i=2,j=0;i<=length;i++){
	//j即代表着下标，也代表着目前已经有多少个元素相匹配了
	while(j&&s[i]!=s[j+1]) j=next[j];//有元素匹配，而且最前的元素不匹配，这是需要移动下面那个串，怎么移动，移动到next[j];

	if(s[i]==s[j+1]) j++;//不管有没有元素匹配，如果最前的元素匹配了，那么已经匹配的元素加一

	next[i]=j;
}
```

这里求解的思想并没有按照求前缀与后缀相等的最大长度。而是在已知next[1]的基础上，按照匹配的思想进行求解next[2]

#### 匹配实现：
```c++
for(int i=1,j=0;i<=n;i++){
	while(j&&a[i]!=b[j+1])j=next[j];//最一般的情况：有元素匹配了，但是最新的元素不匹配，那么需要移动整个串，怎么移动呢，j=next[j];

	if(a[i]==b[j+1]) j++;//不管有没有元素匹配，最新的元素匹配，那么j指针可以往后移一位

	if(j==m)cout<<"YES!"<<endl;//j移到末尾，那么有母串中有子串
}
```

#### 注意：
这里的下标都从**1**开始！！！

## 字典树Trie <a name="section5"></a>

```c++
int t[N][26];
int cnt[N];
int label;

void insert(string s){
	int temp_label=0;
 	for(int i=0;i<s.size();i++){
		char c=s[i]-'a';
		if(t[temp_label][c]==0)t[temp_label][c]=++label;
		temp_label=t[temp_label][c];
	}
	cnt[temp_label]++;
}
```


## 并查集 <a name="section6"></a>

### 主要解决的问题：

将两个集合融合在一起。难点在于，如何把集合中的每个元素的上级都改成另一个。

### 并查集：
每一个集合用树来维护，每一个结点存储父结点。根节点就是集合的编号。

```c++
int p[N];
int find_fa(int x){
    if(p[x]!=x){
        p[x]=find_fa(p[x]);    //减少树的高度，路径压缩
    }
    return p[x];
    
}
```

### 案例_食物链问题分析：

用一个并查集维护已有吃与被吃的关系。当有新的语句加入时，寻找有无相同根节点，有的话证明两者已有关系，进一步证明关系是否正确。反之，默认两者关系正确，再帮两者的**集合合并**起来。

为模拟吃与被吃的关系，由于食物链时一个环（环一般用除余的思想解决），所以可以用离根节点的距离来表示。

集合内的元素之间都具有某种关系。


 ## 堆排序并查集 <a name="section7"></a>

 堆就是一棵完全二叉树，用数组维护，所有的操作可以用up，down两个操作完成.

 下标从一开始


```c++
void up(int i){
	int falg=i;
	if(h[i/2]>h[falg])falg/=2;
	if(flag!=i){
		swap(h[i],[flag]);
		up(flag);
	}
	
}

void down(int i){
    int flag=i;
    if(i*2<=Size&&h[i*2]<h[flag])flag=i*2;
    if(i*2+1<=Size&&h[i*2+1]<h[flag])flag=i*2+1;
    if(flag!=i){
        swap(h[i],h[flag]);
        down(flag);
    }
}
//建堆
    for(int i=n/2;i>=1;i--)down(i);//从n/2 开始down是O（n）的复杂度
```

## 哈希 <a name="section8"></a>

用数值代表元素，所以需要用函数来将元素映射到数。

- 元素是数值，则一般用除余法得到数值对应的坐标
- 元素是字符串，则一般用**131*法则得到对应的前缀和的值。

```c++
const int N=200003;//比数组个数大的最小质数
int loc=(x%N+N)%N;//防止x是负数


int P=131;//经验值
for(int i=1;i<=n;i++){
        h[i]=h[i-1]*P+a[i];//a是一个字符串
        p[i]=p[i-1]*P;//存储p的次方p[n]相当于p^n次方
    }
```
