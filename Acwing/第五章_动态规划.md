# 目录：

- [综述](#section1) 
- [背包问题](#section2)
- [线性DP](#section3)


# 综述： <a name="sectino1"></a>
动态规划问题 分析两部分：状态表示，状态计算。

#### 状态表示：
f[x][y]表示的是一个集合，是指在前x个物品，容量不超过y的条件下，总价值最大为多少。

#### 状态计算：
分析f[x][y]有哪几种结果，取最大值为f[x][y]



# 背包问题<a name="section2"></a>



## 01背包：（每件物品最多使用一次）
#### 解决思路：
状态表示：f[x][y]，其中（x，y）代表的是一种状态，f（x,y）表示的是一个选择方案的**集合**，值的**属性**就是我们要求的目标。

状态计算：这个选择方案的**集合**可以分为f[x-1][y]和f[x-1][y-v[i]]+w[i]，即取不取i两种情况，取两种情况中最大的值作为f[x][y]。

**为什么可以求解出来，因为有了初始化的值，所以上式其实就是递推式，相当于知道T(1)，和递推式，可以求T(n)。**

#### 优化：
先做朴素，再去对方程进行优化，这里用覆盖法直接把新值覆盖在当前位置。减少val的维数。f[j]=max(f[j],f[j-v[i]]+w[i])

#### 注意：
- 当选择要取x之前，要判断当前容量能不能取x!
- 这里因为是f[x-1][y-v[i]]+w[i]，所以循环是从大到小。


## 完全背包：（无限次）
#### 解决思路：
状态表示：同上。

状态计算：方案的**集合**可以分为f[x-1][y]和f[x-1][y-k*v[i]]+k*w[i].........，即取多少个的情况，取最大的值作为f[x][y]。
#### 优化：
f[i][j]=max(f[i-1][j],f[i][j-v[i]]+w[i]);

#### 注意：
- 当选择要取x之前，要判断当前容量能不能取x!
- 这里因为是f[i][j-v[i]]+w[i]，所以循环是从小到大。

## 多重背包（每种物品有固定个数）
#### 解决思路：
状态表示：同上。

状态计算：同完全背包
#### 优化：
用二进制数分离每种物品的个数,将其化解成01背包问题。
```c++
for(int i=1;i<=n;i++)
    {
        cin>>x>>y>>z;
        int k=1;
        while(k<=z)
        {
            v[++idx]=x*k;
            w[idx]=y*k;

            z-=k;
            k*=2;
        }
        if(z>0)
        {
            v[++idx]=x*z;
            w[idx]=y*z;
        }
        
    }
```


## 分组背包（每组的东西只能取一个）
思想与01背包相似，只是分的情况不止两种。

#  线性DP <a name="sectino3"></a>
拓宽了动态规划问题的思路。

动态规划问题中，状态的表示这一大要素可以有以下几个考虑的点：
- 对目前状态取还是不取的问题（背包）
- 对上一个状态的划分（比如上一步走左还是走右）（数字三角形）
- 对上一个状态的划分（固定此时的状态，然后循环遍历此前的状态，然后计算当前状态对应的值）（最长上升子序列）


## 最长公共子序列
其实是背包问题，f[i][j]表示a中的前i个字母,b中的前j个字母，分为此时取不取i，j(四种情况)，属性是最大相等的子序列.

四种情况分别是:f[i][j]=max(f[i-1][i-1],f[i-1][j],f[i][j-1],f[i-1][j-1]+1)

其中f[i-1][j-1]+1的前提是a[i]=b[j]。前三个条件有重叠部分，但划分的最主要的条件是不遗漏，所以重叠是没关系的

- **为什么会重叠：**f[i-1][j]只是表示不取a[i],但取不取b[j]是不确定的。


## 编辑距离































