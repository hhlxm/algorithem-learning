# 目录：

- [综述](#section1) 
- [背包问题](#section2)
- [线性DP](#section3)


# 综述：<a name="sectino1"></a>
动态规划问题 分析两部分：状态表示，状态计算。

#### 状态表示：
f[x][y]表示的是一个集合，使达到（x,y）的方法的集合

#### 状态计算：
分析所有方法中的**最优**方法。

状态转换公式的列出：看对所有阶段的元素都可以进行哪些操作，然后对上一阶段进行不同的操作，且要达到现阶段的条件，计算时，要加上上一段的值再加上为了到现阶段的值



# 背包问题：<a name="section2"></a>
当前有哪几种操作方式，选择一种，那么再去选取相应的已知值
dp[i][j]=dp[i-1]dp[j],dp[i-1][j-v[i]]+w[i]


## 01背包：（每件物品最多使用一次）
#### 解决思路：
状态表示：f[x][y]，其中（x，y）代表的是一种状态，f（x,y）表示的是一个选择方案的**集合**，值的**属性**就是我们要求的目标。

状态计算：这个选择方案的**集合**可以分为f[x-1][y]和f[x-1][y-v[i]]+w[i]，即取不取i两种情况，取两种情况中最大的值作为f[x][y]。

**为什么可以求解出来，因为有了初始化的值，所以上式其实就是递推式，相当于知道T(1)，和递推式，可以求T(n)。**

#### 优化：
先做朴素，再去对方程进行优化，这里用覆盖法直接把新值覆盖在当前位置。减少val的维数。f[j]=max(f[j],f[j-v[i]]+w[i])

#### 注意：
- 当选择要取x之前，要判断当前容量能不能取x!
- 这里因为是f[x-1][y-v[i]]+w[i]，所以循环是从大到小。


## 完全背包：（无限次）
#### 解决思路：
状态表示：同上。

状态计算：方案的**集合**可以分为f[x-1][y]和f[x-1][y-k*v[i]]+k*w[i].........，即取多少个的情况，取最大的值作为f[x][y]。
#### 优化：
f[i][j]=max(f[i-1][j],f[i][j-v[i]]+w[i]);

#### 注意：
- 当选择要取x之前，要判断当前容量能不能取x!
- 这里因为是f[i][j-v[i]]+w[i]，所以循环是从小到大。

## 多重背包：（每种物品有固定个数）
#### 解决思路：
状态表示：同上。

状态计算：同完全背包
#### 优化：
用二进制数分离每种物品的个数,将其化解成01背包问题。
```c++
for(int i=1;i<=n;i++)
    {
        cin>>x>>y>>z;
        int k=1;
        while(k<=z)
        {
            v[++idx]=x*k;
            w[idx]=y*k;

            z-=k;
            k*=2;
        }
        if(z>0)
        {
            v[++idx]=x*z;
            w[idx]=y*z;
        }
        
    }
```


## 分组背包：每组的东西只能取一个）
思想与01背包相似，只是分的情况不止两种。


# 线性DP：<a name="sectino3"></a>
拓宽了动态规划问题的思路。

动态规划问题中，状态的表示这一大要素可以有以下几个考虑的点：
- 对目前状态取还是不取的问题（背包）
- 对上一个状态的划分（比如上一步走左还是走右）（数字三角形）
- 对上一个状态的划分（固定此时的状态，然后循环遍历此前的状态，然后计算当前状态对应的值）（最长上升子序列）


## 最长公共子序列：
先看上一状态的下一个元素匹配与不匹配，且最后满足条件的最优值
- 匹配 dp[j]+1
- 不匹配 dp[j]

其实是背包问题，f[i][j]表示a中的前i个字母,b中的前j个字母，分为此时取不取i，j(四种情况)，属性是最大相等的子序列.

四种情况分别是:f[i][j]=max(f[i-1][i-1],f[i-1][j],f[i][j-1],f[i-1][j-1]+1)

其中f[i-1][j-1]+1的前提是a[i]=b[j]。前三个条件有重叠部分，但划分的最主要的条件是不遗漏，所以重叠是没关系的

- **为什么会重叠：**f[i-1][j]只是表示不取a[i],但取不取b[j]是不确定的。


## 编辑距离：

先看上一个状态的下一个元素匹配与不匹配，且满足最终条件的最优值。

- 增加： dp[i][j]=dp[i][j-1]+1
- 删除： dp[i][j]=dp[i-1][j]+1
- 修改:  dp[i-1][j-1]+a[i]==b[j]



# 区间Dp
区间Dp模板：
```c++
for (int len = 1; len <= n; len++) {         // 区间长度
    for (int i = 1; i + len - 1 <= n; i++) { // 枚举起点
        int j = i + len - 1;                 // 区间终点
        if (len == 1) {
            dp[i][j] = 初始值
            continue;
        }

        for (int k = i; k < j; k++) {        // 枚举分割点，构造状态转移方程
            dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + w[i][j]);
        }
    }
}

```

# 状态压缩
将每一个位置有无表示成二进制0/1，用十进制数标识表示状态。

用dp中的一维状态。

```c++
//最短hamilton路径，dp[i][j]，第一维表示路径，第二维表示终点
for(int i=0;i<(1<<n);i++)// 0000000000-1111111111所有路径
    {
        for(int j=0;j<n;j++)//最后走到第j个点
        {
            if(i>>j&1)//路径中有j才对
            {
                for(int k=0;k<n;k++)//j的前一个点是k
                {
                    if(i>>k&1)//路径中有k才对
                    {
                        f[i][j]=min(f[i][j],f[i-(1<<j)][k]+w[k][j]);//所有的点走到k这个点，加上k走到j
                    }
                }
            }
        }
    }
```

# 树形DP
与dfs一起使用，后序遍历

# 记忆化搜索
用一个初始化为-1的f数组来记录每一个状态的答案，如果f是-1则没有被计算，进行计算，如果已经计算好了，就直接返回了。


```c++
int fun(int i,int j)
{
    if(f[i][j]!=-1)return f[i][j];//如果计算过了，则可以直接返回
    
    f[i][j]=1;//初始化
    
    for(int k=0;k<4;k++)
    {
        int x=i+op[k].first;
        int y=j+op[k].second;
        if(x>=1&&x<=r&&y>=1&&y<=c&&w[x][y]<w[i][j])//满足条件
        {
            f[i][j]=max(f[i][j],fun(x,y)+1);//计算f[i][j];注意：f[x][y]是已知值，所以需要计算。
        }
        
    }
    
    return f[i][j];//把这个点返回
    
}
```

# dfs和递归的区别
dfs主要是寻找每一种方案，而递归则是求值






















